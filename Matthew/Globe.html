<html>
<head>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script src="https://unpkg.com/topojson@3.0.2/dist/topojson.js"></script>
  <script src="versor.js"></script>
  <style>
  html, body {
    margin: 0;
    padding: 0;
    background: #555;
  }
  </style>
</head>
<body>
  <h2 id="current"></h2>
  <canvas id="globe"></canvas>
  <script>
  //
  // Configuration
  //

  // ms to wait after dragging before auto-rotating
  // scale of the globe (not the canvas element)
  var scaleFactor = 0.5
  // start angles
  var angles = { x: 0, y: 40, z: 0}
  // colors
  var colorWater = '#fff'
  var colorLand = '#111'
  // Variables
  //

  var current = d3.select('#current')
  var canvas = d3.select('#globe')
  var context = canvas.node().getContext('2d')
  var water = {type: 'Sphere'}
  var projection = d3.geoOrthographic().precision(0)
  //var graticule = d3.geoGraticule10()
  var path = d3.geoPath(projection).context(context)
  var v0 // Mouse position in Cartesian coordinates at start of drag gesture.
  var r0 // Projection rotation as Euler angles at start.
  var q0 // Projection rotation as versor at start.
  var lastTime = d3.now()
  var degPerMs = .006
  var width, height
  var land, countries
  var autorotate, now, diff

  //
  // Functions
  //

  function setAngles() {
    var rotation = projection.rotate()
    rotation[0] = angles.y
    rotation[1] = angles.x
    rotation[2] = angles.z
    projection.rotate(rotation)
  }

  function scale() {
    width = document.documentElement.clientWidth
    height = document.documentElement.clientHeight
    canvas.attr('width', width).attr('height', height)
    projection
      .scale((scaleFactor * Math.min(width, height)) / 2)
      .translate([width / 2, height / 2])
    render()
  }

  function startRotation() {
    autorotate.restart(rotate)
  }

  function stopRotation() {
    autorotate.stop()
  }

  function dragstarted() {
    v0 = versor.cartesian(projection.invert(d3.mouse(this)))
    r0 = projection.rotate()
    q0 = versor(r0)
    stopRotation()
  }

  function dragged() {
    var v1 = versor.cartesian(projection.rotate(r0).invert(d3.mouse(this)))
    var q1 = versor.multiply(q0, versor.delta(v0, v1))
    var r1 = versor.rotation(q1)
    projection.rotate(r1)
    render()
  }

  function dragended() {
    startRotation()
  }

  function render() {
    context.clearRect(0, 0, width, height)
    fill(water, colorWater)
    fill(land, colorLand)
  }

  function fill(obj, color) {
    context.beginPath()
    path(obj)
    context.fillStyle = color
    context.fill()
  }

  function rotate(elapsed) {
    now = d3.now()
    diff = now - lastTime
    if (diff < elapsed) {
      rotation = projection.rotate()
      rotation[0] += diff * degPerMs
      projection.rotate(rotation)
      render()
    }
    lastTime = now
  }

  function loadData(cb) {
    d3.json("world-50m.json", function(error, world) {
        cb(world)
    });
  }
  setAngles()

  canvas.call(d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended)
     )

  loadData(function(world) {
    land = topojson.feature(world, world.objects.land)
    countries = topojson.feature(world, world.objects.countries)

    window.addEventListener('resize', scale);
    scale();
    autorotate = d3.timer(rotate);
    })
  </script>
</body>

</html>
